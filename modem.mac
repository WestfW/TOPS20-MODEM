;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.314, 10-Apr-85 19:42:18, Edit by WANCHO; Restored net binary mode negotiations to be done only if N option used.; Made net binary code into subroutines NETBON and NETBOF.;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.313,  9-Apr-85 00:40:19, Edit by MRC; Added conditional code for PANDA MONITR's handling of network binary;mode negotiations and doubling of FFH's.;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.312,  9-Feb-85 09:42:10, Edit by WANCHO; No longer writes ITS Binary Header;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.311,  9-Jan-85 07:35:40, Edit by WANCHO; Forgot to do SFPTR% to set pointer back if input file was tested for; ITS mode and wasn't - in IPNFIL.;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.310,  7-Jan-85 20:43:45, Edit by WANCHO; Reorganized file type determination code to allow for ITS Binary;  Mode files of bytesize 8 (as written by TOPS-20 SQ) as well as 36.; ITS Binary files are now defaultly written with bytesize 8 instead of 36.;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.309, 21-Nov-84 09:33:26, Edit by WANCHO; Cleared F%ITS and F%B in MSEND and SEND to ignore previous settings;  by IPNFIL or by user.;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.308, 14-Nov-84 21:40:04, Edit by WANCHO; Added push/pop of 2 in CSUM.  Checksum mode should now work again!;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.307, 16-Oct-84 18:04:29, Edit by WANCHO; Set the remote device speed to 0, per BillW's suggestion, in HALT; Added code in Help to allow paging of the help display, from Frank DaCruz;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.306, 16-Oct-84 06:33:28, Edit by WANCHO; Fixed logical error in INIWAI - was aborting if not C or CAN;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.305, 13-Oct-84 21:52:24, Edit by WANCHO; HALT now closes and releases the JFN on MODEM-DEVICE: so that a; superior process, such as DIAL, will work in a v6.n environment.;[SIMTEL20]PS:<SOURCES.MICRO>NMODEM.MAC.304,13-Oct-84 20:56:34, Edit by WANCHO; ABORT now calls CLSFIL to avoid the "invalid simultaneous access" problem; Added OF%THW to OPENF% of TTY or PTY; Changed 10B4 to 10B5 in same places;;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.303,  5-Oct-84 18:49:06, Edit by WANCHO;; Reinstated the GETTIM routine and use its value for the GETSTR t/o.;; Moved the checksum calculation in RECEIVE to AFTER receiving the;  remote checksum to avoid a potential timing problem.;;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.302, 17-Sep-84 00:27:51, Edit by WANCHO; The following details the changes made in the jump from 249 to 302.; Most are mainly changes to fully implement the timeout and recovery; features in MDM730.  Others fix long standing and some somewhat; obscure bugs.;; This list is mostly in the sequential order of the program source:;; 1.  Due to the extent of the changes, especially the changes in the; timeout mechanism, the major version number of the program has been; upped from 4.0 to 5.0, and the Edit number jumped to the 300 series.; 2.  This version now contains the MACRO directives SALL and FLBLST; for cleaner listings, and contains the LINK directives /NOINITAL and; MODEM/SAVE.  Ignore the %LNKTDS error.  That latter directive means; the LINK step will automatically do the SAVE for you.; 3.  The timeout counter TIMCNT is now a register (11).;; 4.  A new macro TMOSET was added to make setting timeout values; easy, and all the timeout values are now easily changed variables.;; 5.  Subroutines GETACK and GETNAK were added.  Each will wait up to; 15 seconds for an ACK or up to two minutes for a NAK, respectively.; These routines replaced those sections of code where a single ACK or; NAK was gotten with no timeouts, especially in MSEND and elsewhere.;; 6.  All GETCHR calls are now preceded by a timeout setting and; GETCHR clears and resets the timer to that value.  GETCHR returns +1; if a character is received within the timeout limit, else it returns; +2.  The timer is cleared in either case.;; 7.  MSEND now sends a 75H ("u") if the remote sends a bad checksum; back on the received filename, and tries again.;; 8.  MSND.F clears F%MULT before returning to CMDLP.;; 9.  SEND now calls DISINT to disable interrupts if the terminal is; used as the MODEM-DEVICE.  Because it had failed to do this, the; checksums returned by the remote for certain filenames always; failed.  Likewise, spurious received noise would mysteriously cause; the program to appear to hang because this was not called.;; 10. SEND also clears F%MULT just in case...;; 11. GETTIM has been flushed in favor of using known reasonable; timeout values for GETSTR.;; 12. A two-minute timeout was added to SFILE's INIWAI loop, waiting; for a "C", a NAK, or now also a CAN.;; 13. SFILE's DOEOF now sends the EOF and waits for an ACK in a loop; (without a timeout as per MDM730).  This may change.;; 14. SFILE's ACKWAIT will keep trying for an ACK, NAK, or CAN in a; timout loop up to 192 seconds or 192 characters, whichever comes; first, per MDM730, before aborting.  However, up to 10 NAK retries; still applies.;; 15. TYPFIL does not display the trailing and usually wrong info; about a wild-card file, just the wildcard name.;; 16. RECEIVE clears F%MULT before the test is made to see if the; request is for a batch mode receive.;; 17. ININAK in RECEIVE now tests for and allows first trying CRC mode; (with up to 6 ten-second timeouts), then CHECKSUM mode, with up to; 10 sixteen-second timouts waiting for a NAK.  Both checks also look; for CAN.;; 18.  All subsequent calls to GETCHR are with sixteen-second timeouts; that go to WAITQ1 first, which calls WAITQ to wait for the line to; clear for at least one second before jumping back to SNDNAK.;; 19. GETSTR now has its own 20-second timeout and uses SOUT to; display to the controlling console if a third line is in use, and; its +1 return also goes to WAITQ1.;; 20. RECEIVE now keeps a separate count of records received in RECNUM; for possible display to the controlling terminal.  This count; doesn't rollover at 255...;; 21. All combinations of "movei 2,ACK" then "call sndchr" were; replaced by a "call SNDACK" where SNDACK has the movei and falls; through to SNDCHR.;; 22. ABORT and RCVERR call WAITQ before eventually jumping back to; CMDLP.;; 23. GETFIL revamped to add the equivalent of MDM730's HSNAK routine,; plus other timeouts and retries ala MDM730.  GETFIL retries; indefinitely, but HSNAK will quit after three minutes per MDM730.;; 24. GFILLP uses register 7 instead of 3 so as not to get stomped on; by the GETCHR routine.;; 25. MULERR has been flushed.;; 26. SETTIM and INTER have been replaced by a heavily modified; version of the SETTIM/TIMINT approach used in MMAILR.  The new; routine also sets PC%USR for the timeout return address which was; NOT set by the old version!;; 27. The HELP text has been reformatted.  However, it still rolls off; the screen because page mode has already been defeated at that; point.  This will probably be changed later.;;[SIMTEL20]PS:<SOURCES.MICRO>NMODEM.MAC.249,10-Sep-84 03:54:22, Edit by WANCHO; Fixed no more files detection on batch receive in GETFIL;[SIMTEL20]PS:<SOURCES.MICRO>NMODEM.MAC.248,10-Sep-84 00:31:10, Edit by WANCHO; Don't display block numbers if View (F%V) is set;[SIMTEL20]PS:<SOURCES.MICRO>NMODEM.MAC.247, 9-Sep-84 18:39:51, Edit by WANCHO; changed F%ARPA to F%DDN.; changed ARPANet to DDN.; corrected various typos.; changed minimum timeout to 10 seconds instead of 3.; don't send ^Vs in filenames!; added code from DIAL to set up slaved port; fixed nout in SEND also, and made RECEIVE display RECSAV instead of; LSTREC, which is modulo 255...;[SIMTEL20]PS:<SOURCES.MICRO>MODEM.MAC.246,  8-Sep-84 21:50:42, Edit by WANCHO; expanded nout to four places (and backspaces);[SRI-KL]PS:<BILLW>MODEM.MAC.244, 21-Apr-84 14:20:42, Edit by BILLW; add return instruction in DISINT!;<BILLW>NMODEM.MAC.237,  9-Jan-84 19:54:24, Edit by BILLW; add multiple send.  Have errors occuring when receiving or; transmitting a filename clean up after themselves.;<BILLW>NMODEM.MAC.206,  2-Nov-83 17:59:34, Edit by BILLW; things to make multiple receive work.  Include ^Z in file name; checksum, do only CHKSUM type transfers, wait 2 secs bfore FN NAK,; quote all filename chars with ^V;  (doesn't matter on chars that don't need it!),;<BILLW>NMODEM.MAC.201, 19-Oct-83 15:48:21, Edit by BILLW; multiple file receive added.  Major version set to 4, edit to 200.;<BILLW>NMODEM.MAC.20, 31-Jul-83 18:05:41, Edit by BILLW; fixed an obscure bug with FF quoting in ARPA mode. (SNDSTR);<BILLW>MODEM.MAC.133, 30-Jun-83 17:36:09, Edit by BILLW; implement . subcommand for "T" command and subcommand to set speed of; terminal.  If the speed is set, then it is reset to 0 on "D" command.; examples:	MODEM>T.300		MODEM>CT115T.9600; the speed is not altered in XMODEM mode (eg: only valid for "calling"; another terminal.  This routine is in the wrong place to handle; autodialers with multiple speeds...;<BILLW>MODEM.MAC.128, 30-Jun-83 16:22:43, Edit by BILLW; make TTY mode use multiple forks.  Improve error reporting.;<Billw>Modem.mac.124, 29-Apr-83 15:47:39, Edit by BILLW; remove DDN hacks (new monitors work better?) still available via option; fix logging macros, add more logging, change numbers to Hex in log file; fix timing problems in CRC mode. 4 seconds won't even cover xmit time!; send "C" immediately if we are MASTER device.;<BILLW>MODEM.MAC.115, 11-Nov-82 17:37:47, Edit by BILLW; 10 second pause in receive before sending initial NAK/"C";<BILLW>MODEM.MAC.112,  8-Nov-82 16:57:17, Edit by BILLW; fixed bugs in CRC receive.  added debug message if switch to checksum;<BILLW>MODEM.MAC.107,  7-Nov-82 22:38:01, Edit by BILLW; added crc16 option on receive.  If a SOH is not received within 4; seconds, we switch back to checksum mode;<BILLW>MODEM.MAC.105,  5-Nov-82 16:28:29, Edit by BILLW; added crc16 option to SEND option.  (converted 8080 code to DEC20ness);<BILLW>MODEM.MAC.91, 28-Oct-82 14:46:06, Edit by BILLW; horrible hacking at RMLAST and GETEOF to prevent extra characters; (nulls or ^Zs) at the end of a transferred file.;<BILLW>MODEM.MAC.71, 21-Oct-82 14:20:54, Edit by BILLW; automatically detect TVTs;<BILLW>MODEM.MAC.63, 16-Oct-82 21:42:38, Edit by BILLW; added READY to receive/xmit file message at beginning of transfer;<BILLW>MODEM.MAC.62, 16-Oct-82 16:45:47, Edit by BILLW; made timouts for downloading >> timeouts for uploading.  This is; because it seems to be very dangerous to send text to a micro that; isn't listening.  In particular, they can be acknowledging an old; packet, while the current packet is being transmitted.  On the other; hand, to lose a character due to buffer overflow is quite common; when uploading at high speeds, so that it is in the best interests of; throughput to make this timout as short as possible.;<WANCHO>MODEM.MAC.58, 12-Oct-82 19:09:47, Edit by WANCHO; extended 10-second timeout value to 15 seconds and corrected; some spelling errors in Help info.;<BILLW>MODEM.MAC.52,  7-Oct-82 14:04:40, Edit by BILLW; fixed several bugs in TAC/TIP code (TACs aren't the same;  as TIPs - they also need WILL TRNBIN); support of ITS/LMODEM .COM file format, and automatic detection of same.;  (sixbit/DSK8/ in word 0, rest just 4 8bit bytes/word) ("I" option); DMESG debugging macro writes to MODEM-DEBUG.LOG file; fixed transmission of extra block for file with even number of blocks;<BILLW>MODEM.MAC.25, 27-Sep-82 16:51:41, Edit by BILLW; make it work woth Tip/TAC DDN connections;  DO TRANSMIT BINARY negotiaition;  transmit FFs twice; turn off PAUSE (on) COMMAND mode; check for incrementing block numbers; fix bug that typed backspaces even when using .priou for transfer; leave null instead of ^Z at EOF; (thanks to Ted Shapin (ADMIN.SHAPIN@isib) for the original fixes to;  some of these problems, and to Frank Wancho, (FJW@MIT-MC) who;  explained how to make it work over the DDN);<BILLW>MODEM.MAC.158, 19-Jul-82 13:46:23, Edit by BILLW; re-enable links on exit.;<BILLW>MODEM.MAC.154,  2-Jul-82 18:09:37, Edit by BILLW; made time-out time dependent on transmission speed	title	MODEM	File transfer program for MICROS <-> TOPS-20ifndef SRIKL,<SRIKL==1>ifndef SRIAI,<SRIAI==0>VWHO==	 7VMAJOR== 5VMINOR== 0VEDIT==	 ^d314;	Written By Bill Westfield for SRI International Networks Group;	Bugs/suggestions/questions to BillW@SRI-KLcomment	~	This program is a Tops-20 implementation of the defacto-standard	MODEM2 File Transfer Protocol as devised by Ward Christensen?.	The protocol itself is documented in SRI-KL:<MICRO>MODEM2.PROTO	This program attempts to implement to standard user interface,	IE you type commands like:	MODEM <options><suboptions> FILE	to the Twenex EXEC	Hooks are included to use an autodialer or a TTY line when	the Tops-20 system is the "Master" console...	~	SEARCH	MACSYM,MONSYM	SALL			;Supress macro expansions	.DIRECTIVE FLBLST	.TEXT "/NOINITIAL"	.TEXT "MODEM/SAVE"F==	0P==	17A==	15B==	16CRCC==	12		;16 bit CRC  (x^16+x^12+x^5+1)CHKSUM= 13RECNUM= 14TIMCNT=	11EOT==	"D"-100ACK==	"F"-100NAK==	"U"-100SOH==	"A"-100SUB==	"Z"-100CAN==	"X"-100BDNM==	"u"IAC==	377				;DDN TELNET IACWILL==	373				; TELNET will <option>WONT==  374DO==	375				; TELNET do <option>DONT==	376				; TELNET don't <option>TRNBIN== 0				; transmit binaryF%S==	1,,0				;view sent charactersF%R==	2,,0				;view received charactersF%V==	4,,0				;view data onlyF%T==	10,,0				; go into terminal modeF%E==	20,,0				; go into echo modeF%D==	40,,0				;disconnect when doneF%Q==	100,,0				;transfer without messagesF%A==	200,,0				;ASCIIF%B==	400,,0				;binaryF%DEB== 1000,,0				;debug connection to PTY openF%CAP== 2000,,0				;capabilities were enabledF%COMM==4000,,0				;go to command modeF%DDN==10000,,0			; try to work over DDN connectionF%ITS== 20000,,0			;use ITS style binary fileF%CRC== 40000,,0			; use CRC instead of checksumF%SPD== 100000,,0			; user set the speed of the lineF%MULT==200000,,0			;multiple files being transferredifndef TIMFAC,<TIMFAC=<3.0>>		; N times the transmission timeifndef	DEBUG,<DEBUG==0>ifn	DEBUG,<if1, <printx DEBUG mode.>>ifndef USEBIN,<USEBIN==0>ifndef SRIAI,<SRIAI==0>ifndef SRIKL,<SRIKL==0>ife DEBUG,<define dmesg(n1,t1,n2,t2) <>>ifn DEBUG,<define dmesg(n1,t1,n2,t2)<	push	p,1	push	p,2	push	p,3	push	p,4	move	1,DBGJFN	seto	2,	movsi	3,(OT%NDA)	ODTIM%	movei	2,11	BOUT%ifnb <n1>,<ifg n1-4,<move 2,n1>	ifle n1-4,<move 2,<n1-4>(p)>	movei	3,20	NOUT%	 trn >	hrroi	2,[asciz/ t1/]	setzb	3,4	SOUT%ifnb <n2>,<ifg <n2-4>,<move 2,n2>	ifle <n2-4>,<move 2,<n2-4>(p)>	movei	3,20	NOUT%	 trn >	setzb	3,4ifnb <t2>,<hrroi	2,[asciz/ t2/]	SOUT% >	hrroi	2,[byte(7) 15,12,0]	SOUT%	pop	p,4	pop	p,3	pop	p,2	pop	p,1>>BUFSIZ==200				; 128 character buffersopdef	call [pushj P,0]opdef	ret  [popj P,0]ifndef STAT%,<opdef STAT% [jsys 745]>BEGCTR== 0SAVCTR== 0DEFINE %IF<BEGCTR==BEGCTR+1 JRST <%GTNAM(BEG,\BEGCTR)> SAVCTR==SAVCTR+1 %STNAM(SAV,\SAVCTR,BEGCTR)>DEFINE %ELSE<%VAL==%GTNAM(SAV,\SAVCTR) BEGCTR==BEGCTR+1 JRST <%GTNAM(BEG,\BEGCTR)> %STNAM(BEG,\%VAL,.) %STNAM(SAV,\SAVCTR,BEGCTR)>DEFINE %END<%VAL==%GTNAM(SAV,\SAVCTR) SAVCTR==SAVCTR-1 %STNAM(BEG,\%VAL,.)>DEFINE %GTNAM(VAR,IND) <VAR'IND>DEFINE %STNAM(VAR,IND,VAL) <VAR'IND=VAL>define UBIN<ifn USEBIN>define USIN<ife USEBIN>; Macros for initializing and disabling timerTMRTCK==^D1			;Timer tick interval in secondsMIN2==^D120/TMRTCKMIN3==^D180/TMRTCKSEC15=^D15/TMRTCKCNT192=^D192/TMRTCK;The following are the timeouts used by GZ's MMODEM (not here yet):TIMEH=^D30/TMRTCK	;Initial SOH timeoutTIMES=^D20/TMRTCK	;Character timeoutTIMEC=^D10/TMRTCK	;Line flush on errorTIMEQ=^D20/TMRTCK	;Line flush on abortTIMEI=^D160/TMRTCK	;Initial NAK timeoutTIMEA=^D80/TMRTCK	;Inter-sector ACK/NAK timeout; intvl = time-out interval in seconds; retad = time-out error return addressDEFINE	TMOSET	(INTVL) <	MOVNI	1,<INTVL/TMRTCK>;Set the time-out interval in ticks>;DEFINE TMOSETSTART:	RESET%	setz	F,		;zero flagsifn DEBUG,<	movsi	1,(GJ%SHT)	hrroi	2,[asciz/MODEM-DEBUG.LOG;p777777/]	GTJFN%	 trn	move	2,[7b5 + of%app]	OPENF%	 trn	movem	1,DBGJFN#>	movei	1,.priou	RFCOC%	dmovem	2,OLDCOC	dmove	2,[byte(2) 1,1,1,1,1,1,1,2,2,3,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1] ;echo CR, LF, BS, and TAB properly	SFCOC%	RFMOD%	movem	2,OLDMOD	and	2,[^-TT%PGM]		;Turn off pause on command	STPAR%				;So block 13H doesn't stop receiving; No system messages please!	movx	1,.CTTRM		;Get current refuse	movx	2,.MORNT		; setting.	MTOPR%	movem	3,OLDSYS#		;Old sys message status.	movx	2,.MOSNT		;For sys messages.	movx	3,.MOSMN		;Turn them off.	MTOPR%; Clear and refuse links	movx	1,<TL%CRO!TL%COR!TL%SAB!TL%STA!.CTTRM>	seto 	2,			;Clear all links.	TLINK%	 trn	move	P,PDLPTR	movei	1,.FHSLF		;enable interupts	move	2,[LEVTAB,,CHNTAB]	SIR%				; just like in the book	EIR%	hrlzi	2,400000		; just activate one channel	AIC%	movsi	1,(GJ%SHT)	hrroi	2,[asciz/MODEM-DEVICE:/]	GTJFN%				;save device we are using as	 setz	1,			; the data channel (from previous	movem	1,MODDEV		;  invocation of MODEM)	jumpe	1,FRESH	move	2,[10b5 ! OF%RD ! OF%WR ! OF%THW]	OPENF%	 jrst	DEVERR	setz	2,	SFMOD%	STPAR%FRESH:	jumpn	1,.+3	movei	1,.priou	movem	1,MODDEV	setz	1,	RSCAN%	 setz	1,	jumpe	1,NOCMDS		;no commands ?LOOK1:	PBIN%	cain	1,12	 jrst	NOCMDS	caie	1,40			;space indicates start of commands	 jrst	LOOK1	movei	1,.priin	hrroi	2,CMDBUF	movei	3,100	movei	4,12	SIN%				; get commands into buffer	CFIBF%				; discard any other inputPARSE:	move	A,[point 7,CMDBUF]PRIMOP:	ildb	1,A			;get primary option	cain	1,40	 jrst	PRIMOP	caie	1,"r"	cain	1,"R"	 jrst	RECEIVE	caie	1,"s"	cain	1,"S"	 jrst	SEND	caie	1,"E"	cain	1,"e"	 jrst	ECHO	caie	1,"T"	cain	1,"t"	 jrst	TERMINAL	caie	1,"C"	cain	1,"c"	 jrst	DIAL	caie	1,"d"	cain	1,"D"	 jrst	DISCONNECT	caie	1,"x"	cain	1,"X"	 jrst	EXAMPLEHELP:	caie	1,"H"	cain	1,"h"	 jrst [	movei	1,.PRIOU	;They want help text.		RFMOD%		movem	2,NEWMOD	;Save the current terminal mode.		move	2,OLDMOD	;Restore the old one temporarily.		STPAR%		hrroi	1,HLPTXT	;Print the help text.		PSOUT%		movei	1,.PRIOU	;Put terminal mode back as we found it.		move	2,NEWMOD		STPAR%		jrst	CMDLP ]		;Back for another command.	hrroi	1,[asciz/Use MODEM H for help/]	PSOUT%	jrst	CMDLP			;another comand, or exitNOCMDS:	setom	CMFLAGCMDLP:	tlzn	F,(F%CAP)	%IF	 movei	1,-5	 move	2,OLDTIW	 STIW%				;restore previous Interrupt word	 movei	1,.FHSLF	 RPCAP%	 move	3,OLDCAP	 EPCAP%				;disable capabilities	%END	movei	1,.priou	move	2,OLDMOD	SFMOD%	trze	F,(F%COMMA)		;go to command mode ?	 setom	CMFLAG	trze	F,(F%T)			;go to terminal mode ?	 jrst	TERMINAL	trze	F,(F%E)			; or echo mode ?	 jrst	ECHO	trze	F,(F%D)	 jrst	DISCONNECT	skipn	CMFLAG	 jrst	HALT	trz	F,<(<^-<F%DDN!F%SPD>>&<777777,,0>)>	;clear temporary bits;	hrroi	1,[asciz/MODEM>/];	PSOUT%;	hrroi	1,CMDBUF;	move	2,[RD%BEL + 100];	hrroi	3,[asciz/MODEM>/];	RDTTY%;	 jrst	CMDLP	call	CMDPRS	jrst	PARSE			;execute the command lineCMDPRS:	movei	1,csb	movei	2,[flddb. .cmini]	COMND%REPARS:	movei	1,csb	movei	2,[flddb. .cmuqs,cm%sdh,[exp -1,<1b0+1b<"?"-^d32>>,0,0],<Options (or H for Help)>]	COMND%	tlne	1,(CM%NOP)	 jrst	CMDPRS	ldb	1,[point 7,CMDBUF,6]	caie	1,"S"	cain	1,"s"	 jrst	PRSIFI	caie	1,"R"	cain	1,"r"	 jrst	PRSOFICONF:	movei	1,csb	movei	2,[flddb. .cmcfm]	COMND%	tlnn	1,(CM%NOP)	 ret	hrroi	1,[asciz/?Not confirmed/]	ESOUT%	jrst	CMDPRSPRSIFI:	skipa	1,[GJ%OLD+GJ%XTN+GJ%IFG]PRSOFI:	movsi	1,(GJ%FOU+GJ%MSG+GJ%XTN+GJ%IFG+GJ%OFG)	movem	1,CSBJFN	movei	1,csb	movei	2,[flddb. .cmfil]	COMND%	tlne	1,(CM%NOP)	 jrst	FILERR	move	1,2	RLJFN%	 trn	jrst	CONFHALT:	movx	1,.CTTRM	move	3,OLDSYS#		;Old sys message status.	movx	2,.MOSNT		; Restore state	MTOPR%	move	4,OLDMOD		;get old link bits	movei	1,-1	trne	4,TT%ALK		;accept links ?	 tlo	1,(TL%SAB!TL%ABS)	trne	4,TT%AAD		;accept advice ?	 tlo	1,(TL%STA!TL%AAD)	movei	2,-1	TLINK%				;maybe re-enable links/advice	 trn	movei	1,.priou	dmove	2,OLDCOC	SFCOC%				;restore control character echoing	trnn	F,(F%DDN)	%IF	 call	NETBOF		; Turn net binary off	%END	move	2,OLDMOD	SFMOD%	STPAR%				;restore pause commandsifn DEBUG,<move 1,DBGJFN	CLOSF%	 trn >	move	1,MODDEV	cain	1,.priou		; if not the user's terminal,	 jrst	NOREM	movei	2,.MOSPD		; set the speed to 0	setz	3,	MTOPR%NOREM:	move	1,MODDEV	CLOSF%				;close device	 trn	seto	1,			; Release ALL JFNs	RLJFN%	 trn	HALTF%	HALTF%	jrst	START	subttl	SEND a fileMSEND:	tlo	F,(F%MULT)	movem	1,MULJFNNXTSND:	dmove	1,[ASCII "          "]	dmovem	1,buffer	movem	1,buffer+2		;spaces	hrrz	2,MULJFN	hrroi	1,buffer	movx	3,<1b8>			;filename	JFNS%	movei	3,40	idpb	3,1	move	1,[point 7,buffer+1,20]	movx	3,<1b11>		;file type	JFNS%	movei	3,40	idpb	3,1	idpb	3,1	idpb	3,1	setz	3,	idpb	3,1	trz	F,(F%ITS!F%B)		;ignore previous flags	hrrz	1,MULJFN	call	IPNFIL	move	1,OUTJFN	caie	1,.priou		; output directly to teminal ?	trne	F,(F%Q)			;  or noisy mode	%IF	 call	TYPFIL	%ENDSNDNAM:	dmesg	,<Awaiting name NAK>	call	GETNAK		; wait up to 2 mins for a NAK	 jrst	MSND.F		; else give up	call	SNDACK	movei	5,^d11		;11 characters in filename total	move	6,[point 7,buffer]	setz	CHKSUM,FNLOOP:	 ildb	2,6	 cain	2,"V"-100		;don't send ^Vs!	  jrst	FNLOOP	 addi	CHKSUM,(2)	 call	SNDCHR	 call	GETACK	  jrst	SNDNA2	sojg	5,FNLOOP		;repeat for all chars in name	movei	2,SUB	call	SNDCHR	tmoset(^D16)	call	GETCHR			;get checksum	 jrst	SNDNA2	addi	CHKSUM,SUB	andi	CHKSUM,377	caie	2,(CHKSUM)		; do they match ?	 jrst	SNDNA2	call	SNDACK	move	1,FILJFN	call	SFILE	move	1,FILJFN	tlo	1,(CO%NRJ)	CLOSF%	 trn	setzm	EOFFLG	move	1,MULJFN	GNJFN%	 jrst	MSND.F	jrst	NXTSNDSNDNA2:	movei 	2,BDNM		;no, try again.	call	SNDCHR	jrst	SNDNAMMSND.F:	call	GETNAK		;wait 2 mins for a NAK	 trn	call	SNDACK		;always send ACK after NAK	movei	2,EOT		;send EOT to indicate no more files.	call	SNDCHR	hrrz	1,MULJFN	RLJFN%	 trn	tlz	F,(F%MULT)	jrst	CMDLPGETNAK:	movei	TIMCNT,MIN2		; Wait up to 2 minsGETNK1:	tmoset(TMRTCK)	call	GETCHR	 jrst	GETNK2	cain	2,NAK	 jrst	AOSRETGETNK2:	sojg	TIMCNT,GETNK1	retAOSRET:	AOS	0(P)	retGETACK:	movei	TIMCNT,SEC15		; Wait up to 15 secsGETAK1:	tmoset(TMRTCK)	call	GETCHR	 jrst	GETAK2	cain	2,ACK	 jrst	AOSRETGETAK2:	sojg	TIMCNT,GETAK1	retSEND:	call	SUBOPT			;get sub options	trz	F,(F%ITS!F%B)		;ignore flags	skipn	1,MODDEV		; dialer or third line in use?	 movei	1,.priou		;send to normal channel	push	P,1	cain	1,.priou	 call	DISINT	pop	P,1	movem	1,OUTJFN	dmesg	,<SENDing file>	setzm	EOFFLG	movsi	1,( GJ%SHT ! GJ%OLD ! GJ%IFG )	move	2,A	GTJFN%	 jrst	SNDERR	movem	1,MULJFN	movem	1,FILJFN	tlnn	1,(GJ%NAM!GJ%EXT!GJ%DIR)	 call	IPNFIL	call	TYPFIL			;type name if no wildcardsSNDFIL:	move	1,OUTJFN	setz	2,	SFMOD%	trnn	F,(F%DDN)	%IF	 call	NETBON		; turn net binary on	%END	move	1,MULJFN	tlz	F,(F%MULT)	tlne	1,(GJ%NAM!GJ%EXT!GJ%DIR)	 jrst	MSENDSFILE:	move	1,OUTJFN	caie	1,.priou		; output directly to terminal ?	trne	F,(F%Q!F%R!F%S!F%V)	;  or noisy mode	%IF	 hrroi	1,[asciz/Block    /]	 PSOUT%	%END	setz	RECNUM,			;zero record number	movei	TIMCNT,MIN2		; set up for total of 2 minINIWAI:	tmoset(TMRTCK)	call	GETCHR	 jrst	INIWA2	caie	2,"C"			; CRC option requested ?	%IF	 tro	F,(F%CRC)	; set flag to use CRC	 dmesg	,<CRC Mode requested>	 jrst	NEXT	%END	cain	2,CAN	 jrst	ABORT	caie	2,NAK			;wait for initial NAK	%IF	 dmesg	,<Initial NAK received>	 jrst	NEXT	%ENDINIWA2:	sojg	TIMCNT,INIWAI	jrst	ABORTNEXT:	move	1,OUTJFN	CFIBF%	movei	1,^D10	movem	1,ERRCNT#	skipn	EOFFLG			;have we reached the end of the file ?	%IFDOEOF:	 dmesg	,<Sending EOF>	 movei	2,EOT			;if EOF then	 call	SNDCHR	 call	GETACK			; and then wait for ACK back	  jrst	DOEOF	 tlne	F,(F%MULT)	  ret				;return for next file if multiple	 call	CLSFIL	 jrst	CMDLP			; and exit	%END	call	GETBUF			;get a buffers worth from file	jumpe	3,DOEOF			; if 0 bytes read, send EOF	addi	RECNUM,1	movei	TIMCNT,^D10		;reset timeout countAGAIN:	dmesg	,<Transmitting block >,RECNUM	setzb	CHKSUM,CRCC	call	SNDHEADER	move	2,[point 8,buffer]	movni	3,BUFSIZ	call	SNDSTR			;transmit the buffer	trne	F,(F%CRC)	%IF	 call	CSUM			;send checksum	 move	2,CHKSUM	 dmesg	,<Checksum transmitted: >,2	 call	SNDCHR			;and follow with a check-sum	%ELSE	 call	CALCRC	 movei	2,(CRCC)	 dmesg	,<CRC transmitted: >,2	 lsh	2,-8			;high order 8 bits first	 call	SNDCHR	 movei	2,(CRCC)	 call	SNDCHR	%END	movei	TIMCNT,CNT192ACKWAIT:tmoset(TMRTCK)	call	GETCHR			;wait for ACK or NAK	 jrst	ACKW2	cain	2,ACK	 jrst	NEXT1			;all OK, transmit next sector	cain	2,NAK			; oh dear, a NAK...	%IF	 dmesg	2,<received, not ACK or NAK.>	 jrst	ACKW2			;must be one or the other	%END	dmesg	,<NAK received>	sosle	ERRCNT#	 jrst	AGAIN			;  we will try again	hrroi	1,[asciz/10 consecutive NAKs received.  Transfer aborted/]ACKW3:	PSOUT%	jrst	CMDLPACKW2:	sojg	TIMCNT,ACKWAIT	hrroi	1,[asciz/Timeout on ACK - SEND cancelled/]	jrst	ACKW3NEXT1:	dmesg	,ACK received	move	1,OUTJFN	caie	1,.priou		;output not going directly to terminal	trne	F,(F%Q!F%R!F%S!F%V)	; or noisy mode	%IF	 hrroi	1,[byte(7) 10,10,10,10]	 PSOUT%	 movei	1,.priou	 movei	2,(RECNUM)	 move	3,[NO%LFL + <4,,12>]	 NOUT%	  trn	%END	jrst	NEXTSNDHEADER:	movei	2,1			;Start of heading	 call	SNDCHR	movei	2,(RECNUM)		; Record number	call	SNDCHR	setca	2,			; Not (Record Number)	call	SNDCHR	retSNDERR:	hrroi	1,[asciz/SEND error: /]	PSOUT%	call	jerror	jrst	ERRMSG;TYPFIL	Type out a file's name and its size.TYPFIL:	hrroi	1,[asciz/(*** Ready to send /]	PSOUT%	movei	1,.priou	move	2,FILJFN	setz	3,	JFNS%	movei	2,11	BOUT%	move	1,MULJFN	tlne	1,(GJ%NAM!GJ%EXT!GJ%DIR)	 jrst	TYPFL1	hrrz	1,FILJFN	SIZEF%	 setz	2,	move	1,BYTSIZ	caie	1,44			; byte count in 36 bit words ?	%IF	 trne	F,(F%ITS)		; ITS files have 1 word header	  subi	2,1	 trne	F,(F%B)	  imuli	2,4			; 4 8 bit bytes/word	 trnn	F,(F%B)			; or 5 7 bit bytes/word	  imuli	2,5	%END	caie	1,10			; byte count in 8-bit words?	%IF	 trne	F,(F%ITS)		; ITS files have a four-byte header	  subi	2,4	%END	push	P,2	movei	1,.priou	movei	3,12	NOUT%	 trn	hrroi	1,[asciz/ bytes.  /]	PSOUT%	pop	P,2	idivi	2,200	skipe	3	 addi	2,1	push	P,2	movei	1,.priou	movei	3,12	NOUT%	 trn	hrroi	1,[asciz/ (/]	PSOUT%	pop	P,2	movei	1,.priou	movei	3,20	NOUT%	 trn	hrroi	1,[asciz/H)  blocks./]	PSOUT%TYPFL1:	hrroi	1,[asciz/ ***)/]	PSOUT%	ret	Subttl Receive A fileRECEIVE:	call	SUBOPT			;get sub options	movsi	1,(GJ%SHT!GJ%FOU!GJ%IFG!GJ%OFG)	move	2,A	GTJFN%	 jrst	RCVERR	movem	1,FILJFN	tlz	F,(F%MULT)	tlne	1,(GJ%NAM!GJ%EXT)	;wildcard speified ?	 tloa	F,(F%MULT)		; remember so, and don't open file.	call	OPNFIL			;open file depending on mode	hrroi	1,[asciz/Ready to receive /]	PSOUT%	movei	1,.priou	move	2,FILJFN	setz	3,	JFNS%	hrroi	1,[CRLF: byte(7) 15,12,0]	PSOUT%	skipn	1,MODDEV		; dialer or third line in use?	 move	1,.priou		;send to normal channel	movem	1,OUTJFN	setz	2,	SFMOD%	call	GETTIM	trnn	F,(F%DDN)	%IF	 push	P,1	 call	NETBON			; turn net binary on	 pop	P,1	%END	push	P,1	cain	1,.priou		;using control terminal ?	 call	DISINT			; disable ^C interupts	pop	P,1	caie	1,.priou		; output directly to terminal ?	 trne	F,(F%Q!F%R!F%S!F%V)	;  or noisy mode	%IF	  hrroi	1,[asciz/Block    /]	  PSOUT%	%END	tlne	F,(F%MULT)	 setzm	FILJFNNXTRCV:	tlne	F,(F%MULT)	 jrst	GETFILNXTRC1:	setz	RECNUM,			;zero record number	setzm	LSTREC			; pretend already received block 0	movei	TIMCNT,^D7		;reset time-out countININAK:	tro	F,(F%CRC)NOCRC1:	sojle	TIMCNT,NOCRC	movei	2,"C"			; try to start in CRC mode	call	SNDCHR	tmoset(^D10)		; 10-second wait	call	GETCHR	 jrst	NOCRC1	cain	2,EOT	 jrst	RCVDONE	cain	2,CAN	 jrst	ABORT	caie	2,SOH	 jrst	NOCRC1	movei	TIMCNT,^D11	jrst	CRCOKNOCRC:	trz	F,(F%CRC)	movei	TIMCNT,^D11	dmesg	,<switching to Checksum mode>SNDNAK:	sojle	TIMCNT,ABORT	movei	2,NAK	call	SNDCHRRCVLP:	setz	CHKSUM,WAIT:	tmoset(^D16)	call	GETCHR			;should be SOH	 jrst	SNDNAK	cain	2,EOT			; end of file ?	 jrst	RCVDONE			; finished	cain	2,CAN	 jrst	ABORT	caie	2,SOH	 jrst	WAITCRCOK:	addi	CHKSUM,(2)	tmoset(^D16)	call	GETCHR			;record number	 jrst	WAITQ1	movem	2,RECSAV#		; save it...	dmesg	,<Record #>,RECSAV	addi	CHKSUM,(2)	tmoset(^D16)	call	GETCHR	 jrst	WAITQ1	addi	CHKSUM,(2)		;complemented record number	andi	CHKSUM,377	jumpn	CHKSUM,WAITQ1		; SOH + CHKSUM + ^-CHKSUM should be 0	move	1,TIMTIM	call	GETSTR			;get the block	 jrst	WAITQ1	trne	F,(F%CRC)	%IF	 tmoset(^D16)	 call	GETCHR			;get foreign computer's checksum	  jrst	WAITQ1	 call	CSUM			;compute Check sum	 dmesg	2,<Checksum received. >,CHKSUM,<Expected.>	 caie	2,(CHKSUM)		; see if they match...	  jrst	WAITQ1	%ELSE	 tmoset(^D16)	 call	GETCHR	  jrst	WAITQ1	 movei	crcc,(2)	 lsh	crcc,10	 tmoset(^D16)	 call	GETCHR	  jrst	WAITQ1	 addi	crcc,(2)	 push	p,crcc	 call	CALCRC			; calculate checksumifn debug,< move 6,(P) >	 dmesg	crcc,<CRC received. >,6,<Expected.>	 sub	crcc,(p)	 pop	p,(p)	 jumpn	crcc,WAITQ1	%END;OK, we now have a valid block of data. Check if it is an "extra copy"	move	2,RECSAV		;get back record number	camn	2,LSTREC		; same ?	%IF				;  no...	 exch	2,LSTREC	 addi	2,1	 andi	2,377	 exch	2,LSTREC	 came	2,LSTREC	 %IF	  call	PUTBUF			; yes, write it to disk	 %ELSE	  hrroi	1,[asciz/Block synchronization lost./]	  ESOUT%	  jrst	ABORT	 %END	%END	addi	RECNUM,1	movem	2,LSTREC		; save record number	move	1,OUTJFN	caie	1,.priou		; output directly to terminal ?	trne	F,(F%Q!F%R!F%S!F%V)	; Noisy mode ?	%IF	 hrroi	1,[byte(7) 10,10,10,10]	 PSOUT%	 movei	1,.priou	 movei	2,(RECNUM)	 move	3,[NO%LFL + <4,,12>]	 NOUT%	  trn	%END		call	SNDACK			;send positive acknowledgement	movei	TIMCNT,^D10	jrst	RCVLP			; and get next blockRCVDONE:	call	SNDACK	call	CLSFIL	tlnn	F,(F%MULT)	 jrst	CMDLP	jrst	NXTRCVABORT:	call	CLSFIL	seto	1,	RLJFN%	 trn	call	WAITQ	hrroi	1,[asciz/Aborted/]	ESOUT%	jrst	CMDLPRCVERR:	call	WAITQ	hrroi	1,[asciz/RECEIVE error: /]	PSOUT%	call	jerror	jrst	ERRMSGWAITQ1:	call	WAITQ	jrst	SNDNAKWAITQ:	tmoset(TMRTCK)	; Wait for line to go quiet for 1 sec	call	GETCHR	 ret	jrst	WAITQ	Subttl	RECEIVE a filename for multiple file transferGETFIL:	dmesg	,<Receiving a file name>	setz	CHKSUM,	movei	TIMCNT,MIN3		;wait for up to 3 minsHSNAK1:	movei	2,NAK	call	SNDCHR	tmoset(TMRTCK)	call	GETCHR	 jrst	HSNAK2	cain	2,ACK	 jrst	HSNAK3HSNAK2:	sojg	TIMCNT,HSNAK1	jrst	ERRMSGHSNAK3:	dmesg	,<Filename initial ACK received>	move	5,[point 7,atombuf]	movei	6,^d11			;11 chars in file name	setz	7,GFILLP:	tmoset(^D16)	call	GETCHR	 jrst	GETFIL	cain	2,EOT	 jrst	EMRECV			;EOT means no more files	add	CHKSUM,2	caie	2," "			;space or nul ?	 cain	2,0	%IF				; (not space or nul)	  cain	6,^d3			; 9th char ?	   caie	7,0			;  and no "." yet ?	 %IF	    movei 7,"."	    idpb  7,5	 %END	  	 push	P,2	 movei	2,"V"-100	 idpb	2,5	 pop	P,2	 idpb	2,5	%ELSE	 jumpn	7,.+3	  movei	7,"."	  idpb	7,5	%END	call	SNDACK	sojg	6,GFILLP	dmesg	,<11 chars of filename received>	tmoset(^D16)	call	GETCHR	 jrst	GETFIL	caie	2,SUB	 jrst	GETFIL	dmesg	,<SUB received>	movei	2,"Z"-100(CHKSUM)	call	SNDCHR	call	GETACK	 jrst	GETFIL	dmesg	,<Filename acknowledged>	setz	2,	idpb	2,5	hrroi	2,ATOMBUF	movsi	1,(GJ%SHT!GJ%FOU)	GTJFN%	 jrst	NGFN	movem	1,FILJFN	tro	F,(F%ITS!F%B)	call	OPNFIL	movei	1,^d2000	DISMS%	dmesg	,<Returning from GETFIL>	jrst	NXTRC1EMRECV:	call	SNDACK	call	WAITQ	dmesg	,<No more files to receive>;	pop	P,(P)	jrst	ERRMSGNGFN:	dmesg	,<Received filename not valid>	jrst	RCVERR	subttl	Network binary negotiationsNETBOF:				; Turn net binary offIFE PANDASW,<	setz	2,	SFMOD%	dmove	2,[exp <point 8,[byte(8) IAC,WONT,TRNBIN]>,-3]	SOUT%	movei	1,^d4000	DISMS%	movei	1,.priou	dmove	2,[exp <point 8,[byte(8) IAC,DONT,TRNBIN]>,-3]	SOUT%>; IFE PANDASWIFN PANDASW,<	MOVX	1,.CTTRM	; restore modes	MOVX	2,.MOSLT	MOVE	3,OLDLTS	; get former status	MTOPR%;	 ERJMP	FATAL>; IFN PANDASWNETBON:				; Turn net binary onIFE PANDASW,<	dmesg	,<sending DO TRNBIN to TAC>	dmove	2,[exp <point 8,[byte(8) IAC,DO,TRNBIN]>,-3]	SOUT%	push	P,1	movei	1,^d4000	DISMS%	move	1,(P)	dmove	2,[exp <point 8,[byte(8) IAC,WILL,TRNBIN]>,-3]	SOUT%	movei	1,^d4000	DISMS%	pop	P,1>; IFE PANDASWIFN PANDASW,<	MOVX	1,.CTTRM	; read present local status	MOVX	2,.MORLT	MTOPR%;	 ERJMP	NIM		; not a Panda monitor	MOVEM	3,OLDLTS	; save old terminal status	TXO	3,MO%NBI!MO%NBO	; want network binary mode	MOVX	2,.MOSLT	; want to set it	MTOPR%;	 ERJMP	FATAL	MOVX	2,.MORLT	; now see what actually happened	MTOPR%;	 ERJMP	FATAL	TXC	3,MO%NBI!MO%NBO	; make mask ones if either bit zero	IFXN.	3,MO%NBI!MO%NBO	 hrroi	1,[asciz/Could not negotiate Network Binary Mode with your TAC.  Check to makesure your port has Flow Control turned off by issuing the TAC commands"@F O E<cr>" and "@F I E<cr>", and try again./]	 PSOUT%	ENDIF.>; IFN PANDASW	ret	Subttl	Make a call to TTY port or auto-dialerDIAL:	ildb	1,A			;get next character	cail	1,"a"	 subi	1,40			; upper-casify	cain	1,"T"	 jrst	TRYTTY			;try a terminal	cain	1,":"	 jrst	TRYHST			;try a host name	caig	1,"9"	caige	1,"0"			;is it a digit ?	 jrst	CALERR;;;*** Auto dialer code goes hereifn SRIKL,<movei	2,137>ifn SRIAI,<movei	2,140>	call	OPNTTY	move	1,MODDEV	hrroi	2,[asciz/ATDT/]	setzb	3,4	SOUT%	ldb	2,A	BOUT%	move	2,A	SOUT%	movei	2,15	BOUT%	jrst	CMDLP	hrroi	1,[asciz/Sorry, no Autodialers yet./]	PSOUT%	ildb	1,A	caig	1,"9"	caige	1,"0"	 trna	jrst	.-4	call	SUBOPT	jrst	CMDLPCALER1:	hrroi	1,[asciz/Illegal argument to "C" option/]	PSOUT%	jrst	ERRMSGCALERR:	hrroi	1,[asciz/Error dialing number or acquiring TTY line: /]	PSOUT%	call	jerror	jrst	ERRMSG	Subttl	make a "call" to a terminal lineTRYTTY:	ildb	1,A			;next character	cail	1,"a"	 subi	1,40	caie	1,"T"			; also a T ?	 jrst	TTYNUM	ildb	1,A			; "Y"...	cail	1,"a"	 subi	1,40	caie	1,"Y"	 jrst	TTYNUM	ildb	1,ATTYNUM:	cain	1,"D"	 jrst	TDEBUG	setz	2,	caig	1,"9"	caige	1,"0"	 jrst	CALERRTTYLP:	imuli	2,10	addi	2,-60(1)	ildb	1,A	caig	1,"9"	caige	1,"0"	 jrst	TTYDON	jrst	TTYLPTTYDON:	push	P,2	add	A,[7b5]			;back up byte pointer	skipge	A			; .	 sub	A,[43b5+1]		;  .	call	SUBOPT			;get sub options	pop	P,2	call	OPNTTY	jrst	CMDLPOPNTTY:	hrroi	1,DEVNAM	addi	2,400000		;create device number	push	P,2	DEVST%	 jrst	CALERR	movei	2,":"	idpb	2,1			;create name TTYnnn:	movei	1,.CLNJ1	hrroi	2,[asciz/MODEM-DEVICE/]	setz	3,			;delete old name, if any	CRLNM%	 trn	movei	1,.CLNJB	hrroi	2,[asciz/MODEM-DEVICE/]	hrroi	3,DEVNAM	CRLNM%	 jrst	CALERR	pop	P,1	ASND%				;assign device to my job	 jrst	CALERR	hrroi	2,[asciz/MODEM-DEVICE:/]	movsi	1,(GJ%SHT)	GTJFN%				; get a handle on it	 jrst	CALERR	movem	1,MODDEV	move	2,[10b5 ! OF%RD ! OF%WR ! OF%THW]	OPENF%				;and finally, open as modem device	 jrst	CALERR	RFMOD%	movem	2,OLDTTY#	setz	2,	SFMOD%	STPAR%	retTDEBUG:	call	SUBOPT	hrroi	1,[asciz/Getting a PTY.../]	PSOUT%	tlo	F,(F%DEB)	move	1,['PTYPAR']	SYSGT%	hrrzm	1,FIRPTY#	movsi	1,(GJ%SHT)	hrroi	2,[asciz/PTY12:/]	GTJFN%	 jrst	CALERR	movem	1,MODDEV	move	2,[10B5+OF%RD+OF%WR+OF%THW]	OPENF%	 jrst	CALERR	DVCHR%	hrrzi	1,(1)			;get just unit number	add	1,FIRPTY	tro	1,400000		;change to TTY number	movem	1,PTYDD#	movei	2,3	move	1,MODDEV	BOUT%				;send ^C	jrst	CMDLP	Subttl	make a connection to a host, given its name.NOTIMP:	hrroi	1,[asciz/Host not supported yet./]	PSOUT%	jrst	CMDLPTRYHST:	push	P,A			;save start of host name	ildb	1,A	caile	1,"A"			; punctuation ?	jrst	.-2	push	P,A	call	SUBOPT			;get sub-options	pop	P,1	setz	2,	dpb	2,1			;terminate host name with null	pop	P,2			;get start of host name back	movei	1,HSTTAB		;table of host names	TBLUK%	tlne	2,(TL%NOM)	 jrst	NSHOST			;no such host	tlne	2,(TL%AMB)	 jrst	AMHOST			;ambiguous host	hrrz	1,(1)			;get routine	call	(1)	jrst	CMDLPdefine tba(HOSTNAME,DIALROUTINE)<	[asciz/HOSTNAME/],,<DIALROUTINE> >HSTTAB:	HSTLEN,,HSTLEN	tba	DIALER,DODLER		;a dialerifn SRIKL,< tba	MICOM,DOMICM		;the micom>HSTLEN== .-HSTTAB-1	Subttl	Individual Host routineDOMICM:	;;;connect to the CR MICOM	movei	2,124			;TTY conected to MICOM	call	OPNTTY	move	1,MODDEV	movei	2,15	BOUT%				;send CR	retDODLER:ifn SRIKL,<movei	2,137>ifn SRIAI,<movei	2,140>	call	OPNTTY	move	1,MODDEV	hrroi	2,[asciz/AT/]	setzb	3,4	SOUT%	retCRVAX:	call	DOMICM			;first get micom	call	FLUSH	movei	2,15	BOUT%	call	FLUSH	movei	2,"V"	BOUT%	call	FLUSH	movei	2,15	BOUT%	call	FLUSH	movei	2,15	BOUT%	retFLUSH:	movei	1,^d1500	DISMS%	move	1,MODDEV	SIBE%	 jrst	.+2	  retFLUSH1:	BIN%;	movei	1,.priou;	BOUT%;	move	1,MODDEV	SIBE%	 jrst	FLUSH1	jrst	FLUSHAMHOST:	hrroi	1,[asciz/Ambiguous host name/]	PSOUT%	jrst	CMDLPNSHOST:	hrroi	1,[asciz/No such host name/]	PSOUT%	jrst	CMDLP	Subttl	TERMINAL and ECHO modesTERMINAL:	ldb	1,A	cain	1,"."	 jrst	SETSPD	ildb	1,A	caie	1,"."			; see if speed was specified	 jrst	NOSPDSETSPD:	setz	3,	ildb	1,A	caie	1,15	cain	1,12	 jrst	SETSP2	imuli	3,12	addi	3,-60(1)	jrst	SETSPD+1SETSP2:	move	1,MODDEV	cain	1,.priou	 jrst	NOSPD	movei	2,.MOSPD	hrl	3,3	MTOPR%	 ercal	jerror	tro	F,(F%SPD)		; we set the speed!NOSPD:	trz	F,(F%S!F%R!F%V)		;don't view characters	movei	1,.priou	setz	2,	SFMOD%				;set 8 bit/no echo mode	call	DISINT			;disable ^C, etc	move	1,MODDEV	cain	1,.priou		;using control terminal ?	 jrst	GETTTY			; don't use seperate fork	move	1,[CR%MAP ! CR%ST ! GETMOD]	CFORK%	 erjmp	FRKERR	movem	1,MODFRK	jrst	GETTTYFRKERR: hrroi	1,[asciz/Can't get extra fork for TTY mode: /]	ESOUT%	call	jerror	jrst	CMDLPjerror:	hrloi	2,.fhslf	movei	1,.priou	setz	3,	ERSTR%	 trn	  trn	retGETTTY:	movei	1,.priin	SIBE%	 trna	  movei	2,1	move	3,2	push	P,3	movei	4,"E"-100	move	2,[point 8,TTYBUF]	SIN%	ldb	2,2	cain	2,"E"-100	 jrst	TRMEND	move	2,[point 8,TTYBUF]	pop	P,3	move	1,MODDEV	SOUT%	jrst	GETTTYTRMEND:	move	2,[point 8,TTYBUF]	pop	P,3	sojle	3,.+3			;don't output ^E	move	1,MODDEV	SOUT%	skipe	1,MODFRK	KFORK%	jrst	CMDLP	GETMOD:	move	1,MODDEV	SIBE%			;characters in input buffer ?	 trna	  jrst	SNGCHR		; wait for single char if none there	movn	3,2		; make character count	move	2,[point 8,MODBUF]GETMO1:	SIN%GETMO2:	setzb	3,4	idpb	3,2	movei	1,.priou	move	2,[point 8,MODBUF]	SOUT%	jrst	GETMODSNGCHR:	move	2,[point 8,MODBUF]	movni	3,1	SIN%	push	P,2	SIBE%	 jrst	[movn	3,2		 pop	P,2		 jrst	GETMO1]	pop	P,2	jrst	GETMO2ECHO:	jrst	TERMINAL	Subttl	Disconnect commandDISCONNECT:	setzm	CMFLAG	move	1,MODDEV	cain	1,.priou	 jrst	NODEV	trzn	F,(F%SPD)		;need to reset speed ?	 jrst	NODEV	movei	2,.MOSPD	setz	3,	MTOPR%	 erjmp	.+1NODEV:	hrli	1,(CO%NRJ)	CLOSF%				;close device	 trn	movei	1,(1)	DVCHR%	RELD%				;deassign it	 trn	movei	1,.CLNJ1	hrroi	2,[asciz/MODEM-DEVICE/]	setz	3,			;delete logical name...	CRLNM%	 trn	seto	1,	RLJFN%				; finally release the JFN	 trn	jrst	CMDLP	Subttl	TIMER routines;;;Here to initialize the timer, called via JSP 4,SETTIMSETTIM:	MOVE	1,[.FHSLF,,.TIMEL]	;Tick the timer	MOVEI	2,<TMRTCK*^D1000>	;Every TMRTCK seconds	SETZ	3,			;On channel 0	TIMER%	 ERJMP	.+1	JRST	(4)CLRTIM:	SETOM	TIMKIL			;Turn off timer recycle	SETZM	INTOK			;Turn off time-out counter	SETZM	TIMLOC			;And the return adr	MOVE	1,[.FHSLF,,.TIMAL]	;Remove any pending timer requests	SETZB	2,3	TIMER%	 ERJMP	.+1			;Ignore errors	RET;;;Here on timer interruptTIMINT:	DMOVEM	1,IN1ACS		;Save ACs	DMOVEM	3,IN1ACS+2	AOSE	TIMKIL			;If we weren't asked to kill the clock	 JSP	4,SETTIM		;Reinitialize the timer	AOSE	INTOK			;Should time out now?	%IF	  SKIPN	1,TIMLOC		;Get time-out routine	   jrst	TIMIN1			;FATAL <No time-out PC set>	  MOVEM	1,INTPC			;Set it	  MOVE	P,TIMRTP		;Reset stack ptr	%ENDTIMIN1:	DMOVE	1,IN1ACS		;Restore ACs	DMOVE	3,IN1ACS+2	DEBRK%GETTIM:	;;;	This routine sets up the timeout time as being 3 times;		The length of time that it should take to transmit a;		full packet based on the terminal speed of transfer line.;	movni	3,^d13			;preset default to 13 seconds	movem	3,TIMTIM		; for worse-case 300 baud	move	1,OUTJFN	movei	2,.MORSP		;get terminal speeds	MTOPR%	 erjmp	RETJMP	jumple	3,RETJMP		; if unspecified use default time	hlrz	2,3			;input speed	hrrz	2,2			;output speed	camle	2,3	 move	2,3			;take the minimum speed	idivi	2,12			;characters per second	fltr	2,2			;float it	move	3,[<128.0>]		; TIMFAC * transmission time	fmpri	3,(TIMFAC)	fdvr	3,2			;convert to seconds per packet	fix	3,3	caige	3,1			;wait at least 1 second though	 movei	3,1	movnm	3,TIMTIMRETJMP:	retDEVERR:EXAMPLE:ERRMSG:	move	P,PDLPTR	jrst	CMDLPSNDACK:	movei	2,ACKSNDCHR:	move	1,OUTJFN	andi	2,377	BOUT%				;send to output channelIFE PANDASW,<	cain	2,377			; FFs must be sent twice...	trnn	F,(F%DDN)		;  ...on DDN connections.	%IF	 caie	1,.priou	 %IF	  BOUT%	  dmesg	,<Quoted an FF in block >,RECNUM,< (SNDCHR)>	 %END	%END>; IFE PANDASW	movei	1,.PRIOU	trne	F,(F%S)			; show Sent characters ?	 BOUT%				;  yes, send to command terminal too	retGETCHR:	SETZM	INTOK		;An interrupt here could be embarrassing	MOVEM	P,TIMRTP	;Save the stack ptr for return	MOVE	2,[PC%USR+CLRTIM]	;Set the return address	MOVEM	2,TIMLOC	MOVEM	1,INTOK	JSP	4,SETTIM	SETZM	TIMKIL	move	1,OUTJFN	BIN%	SETOM	TIMKIL			;Turn off timer recycle	SETZM	INTOK			;Turn off time-out counter	SETZM	TIMLOC			;And the return adr	MOVEM	2,SAVE2	MOVE	1,[.FHSLF,,.TIMAL]	;Remove any pending timer requests	SETZB	2,3	TIMER%	 ERJMP	.+1			;Ignore errors	MOVE	2,SAVE2	movei	1,.priou	trne	F,(F%R)			;show Received characters ?	 BOUT%				; yes	aos	0(P)	retSNDSTR:	move	1,OUTJFN	push	P,3	push	P,2	cain	1,.PRIOU	trnn	F,(F%DDN)	%IF 	 movn	3,3			;ahh DDN - must quote FFs,	 movei	4,377			; so use + length, and FF as EOS	%ENDSNDBAR:	SOUT% 				;send block to other computer	 erjmp	SNDFOO			;strictly for PTY debug mode	cain	3,0			; sent the whole string ?	%IFIFE PANDASW,<	 push	p,2			; if not, must be because string	 movei	2,377			; contains an FF that must be	 BOUT%				; quoted with itself.  So do it.	 pop	p,2>; IFE PANDASW	 dmesg	,<Quoted an FF in block >,RECNUM	 jrst	SNDBAR	%ENDIFE PANDASW,<	trnn	F,(F%DDN)		; now check the last character in the	%IF				; buffer.  If it is an FF, then the	 ldb	2,2			; previous test won't quote it					; properly,	 cain	2,377			; so we must do it here instead!	 BOUT%	 dmesg	,<Quoted an FF in block >,RECNUM	%END>;IFE PANDASW	pop	P,2	pop	P,3	movei	1,.priou	trne	F,(F%S!F%V)		;show Sent characters or view file ?	 SOUT%	retSNDFOO:	movei	1,300	DISMS%				;wait for other process to read	move	1,OUTJFN		; characters out of buffer	jrst	SNDBAR			;send rest of string	GETSTR:	SETZM	INTOK		;An interrupt here could be embarrassing	MOVEM	P,TIMRTP	;Save the stack ptr for return	MOVE	2,[PC%USR+CLRTIM]	;Set the return address	MOVEM	2,TIMLOC	MOVEM	1,INTOK	JSP	4,SETTIM	SETZM	TIMKIL	move	1,OUTJFN	move	2,[point 8,BUFFER]	movni	3,BUFSIZ	SIN%	SETOM	TIMKIL			;Turn off timer recycle	SETZM	INTOK			;Turn off time-out counter	SETZM	TIMLOC			;And the return adr	MOVE	1,[.FHSLF,,.TIMAL]	;Remove any pending timer requests	SETZB	2,3	TIMER%	 ERJMP	.+1			;Ignore errors	movei	1,.priou	move	2,[point 8,BUFFER]	movni	3,BUFSIZ	trne	F,(F%R ! F%V)	 SOUT%	aos	0(P)	retDISINT: tlo	F,(F%CAP)	movei	1,-5	RTIW%	movem	2,OLDTIW#		;save old Terminal interupt word	movei	1,.fhslf	RPCAP%	movem	3,OLDCAP#		;save old capabilities	tlo	3,(SC%CTC)	EPCAP%	movei	1,-5	setzb	2,3	STIW% 				;disable ^C interupts	ret	subttl	crc	CRC generator subroutine	chr==3	c==4;poly==^b10100000000000011b36	; x^16+x^15+x^2+1 (low order bits on left)				; (note that x^16 is shifted out of word)poly==^b10000100000010001b36	; x^16+x^12+x^5+1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;								;;;;		Subroutine to compute new crc			;;;;								;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;calcrc:	move	1,[point 8,BUFFER]	movei	2,BUFSIZ	setz	crcc,crclp:	ildb	chr,1	pushj	p,crc2	sojg	2,crclp	setz	chr,	call	crc2	call	crc2	retcrc2:	push	p,chr	movei	5,10crc2lp:	lsh	chr,1	trze	chr,400	 tro	chr,1		; rotate 8 bit byte 1 bit	lsh	crcc,1	trne	chr,1	 tro	crcc,1		;rotate bit from chr into CRC	trze	crcc,200000	;check whether bit is set	 xori	crcc,10041	; X^16 + x^15 + x^2 + 1	sojg	5,CRC2LP	pop	p,chr	ret	Subttl	CSUMCSUM:	push	P,2	move	1,[point 8,BUFFER]	movei	2,BUFSIZ	 ildb	3,1	 addi	CHKSUM,(3)	sojg	2,.-2	andi	CHKSUM,377		;only 8 bits	pop	P,2	retGETBUF:	move	1,[byte(8) 32,32,32,32]	; fill buffer with ^Zs	movem	1,BUFFER	move	1,[BUFFER,,BUFFER+1]	blt	1,BUFFER+<BUFSIZ/4+2>	hrrz	1,FILJFN	move	2,[point 8,buffer]	movni	3,bufsiz	SIN%	 ercal	GETEOF	addi	3,200			;compute number of bytes read	retGETEOF:	setom	EOFFLG			; SIN inserts a null at EOF !!!	movei	5,32	idpb	5,2	retPUTBUF:	push	P,2	hrrz	1,FILJFN	move	2,[point 8,BUFFER]	movni	3,BUFSIZ	movei	4,SUB	trnn	F,(F%B)			;stop on ^Z for text files	 movn	3,3	SOUT%	cain	3,0			; stopped on ^Z ?	%IFRMLAST:	 RFPTR%				; remove the last character	  trn				; from the file.  This is really	 sos	3,2			; a lot more complicated than	 hrli	1,.FBSIZ		; I would like it to be, but	 seto	2,			; is necessary to avoid inconsistancies	 CHFDB%				; in programs that generate CRCs at	  ercal DSKERR			; each end of the transfer	 hrli	1,.FBBYV	 hrlzi	2,(FB%BSZ)	 hrlzi	3,(7b11)	 CHFDB%	  ercal DSKERR	%END	pop	P,2	retCLSFIL:	hrrz	1,FILJFN	trnn	F,(F%ITS)	%IF	 movei	2,10	 SFBSZ%	  trn	%END	CLOSF%	 trn	retOPNFIL:	skipa	2,[of%wr]IPNFIL:	move	2,[of%rd]	andi	1,-1	setzm	BYTSIZ	trne	F,(F%A!F%B!F%ITS)	;Explicit binary or ASCII mode ?	%IF	 push	P,2	 move	2,[1,,.FBBYV]	 movei	3,4	 GTFDB%	  erjmp NOFDB	 lsh	4,-<^d35-^d11>	 andi	4,77	 movem	4,BYTSIZ#	 caie	4,10			;8 bit bytes ?	 %IF	  push	P,1	  tro	F,(F%B)NOFDB:	  pop	P,1	 %END	 cain	4,44			;36 bit bytes ?	  tro	F,(F%ITS!F%B)	 pop	P,2	%END	hrli	2,(7b5)			;assume ASCII mode	trne	F,(F%B)			;unless binary was requested	 hrli	2,(10b5)	OPENF%	 jrst	FILERR	movem	1,FILJFN	trnn	F,(F%B)			;Binary mode ?	%IF				; look for or write DSK8 word	 trnn	2,OF%WR	 %IF	  trnn	F,(F%ITS)		;ITS mode ?	  %IF;	   dmove	2,[exp <point 8,[byte(8) 223,72,330,0]>,<-4>];	   SOUT%				; write sixbit/DSK8/	  %END	 %ELSE	  BIN%				;or check for sixbit/DSK8/	  caie	2,223	   jrst	NOTITS	  BIN%	  caie	2,72	   jrst	NOTITS	  BIN%	  caie	2,330	   jrst	NOTITS	  BIN%	  jumpn	2,NOTITS	  hrroi	1,[asciz/(*** ITS Binary Mode assumed ***)/]	  call	mabtyp	  tro	F,(F%ITS!F%B)	 %END	%ELSE	 hrroi	1,[asciz/(*** Text Mode assumed ***)/]	 call	mabtyp	 hrrz	1,FILJFN	 setz	2,	 SFPTR%	  ercal DSKERR	 movei	2,7	 SFBSZ%	  jrst	FILERR	%END	retNOTITS:	caie	4,44	%IF	 trz	F,(F%B!F%ITS)	 hrroi	1,[asciz/(*** Text Mode assumed ***)/]	 call	mabtyp	 hrrz	1,FILJFN	 setz	2,	 SFPTR%	  ercal DSKERR	 movei	2,7	 SFBSZ%	  jrst	FILERR	%ELSE	 hrroi	1,[asciz/(*** Tops-20 Binary Mode assumed ***)/]	 call	mabtyp	 hrrz	1,FILJFN	 setz	2,	 SFPTR%	  ercal DSKERR	%END	retMABTYP:	move	10,MODDEV	cain	10,.priou		;if not to main terminal, type it!	tlnn	(F%MULT)		;otherwise, type notes if single file	 PSOUT%				;but not when multiple files	retDSKERR:	repeat 20,< trn>	retFILERR:	hrroi	1,[asciz/File open error: /]	PSOUT%	call	jerror	jrst	ERRMSG	Subttl	Get sub-optionsSUBOPT:	ildb	1,A	caie	1,12	cain	1,0	 ret	cail	1,"a"	 subi	1,40			;upper case-ify	caie	1,15	cain	1,40	 ret	cain	1,"."	 ret	setz	2,OPTLP:	hlrz	3,SUBTAB(2)	jumpe	3,OPTERR	caie	1,(3)	aoja	2,OPTLP	hrrz	1,SUBTAB(2)	tro	F,(1)			;set appropriate bit	jrst	SUBOPT	define $SUB(a) <"a",,(F%'a)>SUBTAB:	$SUB	S			;type SENT characters	$SUB	R			;type RECEIVED chars	$SUB	V			;VIEW file	$SUB	T			;goto TERMINAL mode	$SUB	E			;goto ECHO mode	$SUB	D			;Disconnect	$SUB	Q			;Quiet	$SUB	A			;ASCII	$SUB	B			;Binary	"I" ,, (F%ITS!F%B)		;ITS binary	"N" ,, (F%DDN)			;Network	"," ,, (F%COMMA)	0OPTERR:	hrroi	1,[asciz/Illegal Suboption/]	PSOUT%	jrst	SUBOPT	Subttl	dataCHNTAB:	PHASE 0	1,,TIMINT		;Time-out	REPEAT <^D36-.>,<0>	DEPHASELEVTAB::INTPC			;Priority level table	0	0BUFFER:	block	bufsiz/4 + 2MODBUF:	block	100TTYBUF:	block	100HLPTXT:	asciz/MODEM commands for this version of the TOPS-20 modem programhave the following format:@MODEM <option><suboptions> <file>Where <option> is one of: T	Terminal mode			R	Receive a file E	Echo mode			S	Send a file C	make a call to auto-dialer or TTY line	C98596263	call up the SRI micom	(no auto-dialers exist yet)	CTTY120		use TTY120 for the transfer	C:<host>	do a transfer to <host> (not currently implemented) D	disconnect and deassign autodialer or TTY line H	Print (this) help text.and <sub-options> belong to the following list: B	use Binary mode transfer	R	View Received characters A	use ASCII mode transfer		S	View Sent characters I	file is ITS style binary file	V	View file (data only) N	operate through a DDN TAC	Q	Transfer Quietly D	Disconnect after transfer T	go to Terminal mode after transfer E	go to Echo mode after transferTyping MODEM with no options will cause you to be dropped into commandmode, where MODEM will wait for options, and return when the specifiedaction is complete (useful if you must transfer many files).If a "call" is not placed using the C option, then the job's controllingterminal is used for the file transfer./PDLPTR:	iowd 20,PDL	block	2PDL:	block	20MODDEV:	0MODFRK: 0OUTJFN:	0FILJFN:	0MULJFN:	0EOFFLG:	0CMFLAG:	0INTINS:	0LSTREC:	0NEWMOD: 0OLDMOD:	0OLDLTS:	0OLDCOC:	block 2TIMTIM:	0TIMKIL:	BLOCK	1		;-1 if clock should be killedTIMLOC:	BLOCK	1		;PC to go to on time-outTIMRTP:	BLOCK	1		;Stack ptr for time-out returnINTOK:	BLOCK	1		;Neg if time-out interrupt activeINTPC:	BLOCK	1		;Interrupt PCIN1ACS:	BLOCK	4		;ACs saved over level 1 interruptIN2ACS:	BLOCK	4		;ACs saved over level 1 interruptSAVE2:	BLOCK	1CMDBUF:	block 20DEVNAM:	block 10CSB:	REPARS	.priin,,.priou	-1,,[asciz/MODEM>/]	-1,,CMDBUF	-1,,CMDBUF	20*5 - 1		20*5 - 1		-1,,ATOMBUF	20*5 -1	CSBJFNCSBJFN:	block 20ATOMBUF: block 20EVEC:	JRST	START                             	;START ENTRY	JRST	START                                   ;REENTER ENTRYVERSIO:	BYTE	(3)VWHO(9)VMAJOR(6)VMINOR(18)VEDIT      ;VERSION NO.EVECL==.-EVEC                                           ;LENGTH OF VECTOR	END	<EVECL,,EVEC>